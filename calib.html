<!doctype html>
<html lang="en">
<head>

<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="./theme/css/bootstrap.min.css">
        <script src="./theme/js/bootstrap.min.js"></script>
        <link rel="stylesheet" type="text/css" href="./theme/fontawesome/css/fontawesome.min.css">
        <link rel="stylesheet" type="text/css" href="./theme/css/styles.css">
        <script src=
        "https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js">
            </script>
            <script src=
        "https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js">
            </script>
        <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
        <style>
            .navbar-nav {
                margin-left: auto;
            };
            .jumbotron_class{
                background-image: "background.jpeg";
            };
            body{
                font-family: 'Roboto', sans-serif;
            }
            
        </style>

        <script>
            $("document").ready(function(){
                $("#backdrop_image").click(function(e){
                    e.preventDefault();
                });

                // $("#page_banner").click(function(e){
                //     window.location.href = "./"
                // });
            });
        </script>

         <script src="./theme/js/photoswipe.umd.min.js"></script>
        <script src="./theme/js/photoswipe-lightbox.umd.min.js"></script>
        <link rel="stylesheet" href="./theme/css/photoswipe.css">
        <script src="./theme/js/scramble.js"></script>

        <style>
            li {
                margin: 0;
                padding: 0em;
            }
        </style>

        <script src="./theme/js/spotlight.bundle.js"></script>   
</head>
<body>
    <div class="container">
<div id="page_header">
    <nav class="navbar navbar-expand-md bg-light">
        
        <a class="nav-link" href="./">&nbsp; HOME &#124;	 &nbsp; </a>
        <a class="navbar-brand abs" href="https://www.linkedin.com/in/kushalvyaskv/"><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" height="24" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg></a>
        
        <a class="navbar-brand abs" href="https://github.com/kushalvyas"><svg xmlns="http://www.w3.org/2000/svg" height="1.5em" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a>
        
        <a class="navbar-brand abs" href="https://scholar.google.com/citations?user=0SxLnLcAAAAJ&hl=en"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1.5em"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M390.9 298.5c0 0 0 .1 .1 .1c9.2 19.4 14.4 41.1 14.4 64C405.3 445.1 338.5 512 256 512s-149.3-66.9-149.3-149.3c0-22.9 5.2-44.6 14.4-64h0c1.7-3.6 3.6-7.2 5.6-10.7c4.4-7.6 9.4-14.7 15-21.3c27.4-32.6 68.5-53.3 114.4-53.3c33.6 0 64.6 11.1 89.6 29.9c9.1 6.9 17.4 14.7 24.8 23.5c5.6 6.6 10.6 13.8 15 21.3c2 3.4 3.8 7 5.5 10.5zm26.4-18.8c-30.1-58.4-91-98.4-161.3-98.4s-131.2 40-161.3 98.4L0 202.7 256 0 512 202.7l-94.7 77.1z"/></svg></a>


        <!-- <a class="navbar-brand abs"></a>     -->

        <ul class="navbar-nav ms-auto navbar-right">
            <li class="nav-item">
              <a class="nav-link" href="./research.html">
                Research
              </a>
            </li>
            <!-- <li class="nav-item">
                <a class="nav-link" href="./about.html">
                  About
                </a>
            </li> -->
            <li class="nav-item">
                <a class="nav-link" href="./photography.html">
                  Photography & Music
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="./blog.html">
                  Blog
                </a>
            </li>
        </ul>
    </nav>

</div>        <div id="page_banner">
<div>
    <!-- Jumbotron -->
    <div class="p-5 text-center bg-image rounded-3">
      <div class="mask" style="background-color: rgba(0, 0, 0, 0.6);">
        <div class="d-flex justify-content-center align-items-center h-100">
          <div class="text-white">
            <h1 class="mb-3">Demystifying Geometric Camera Calibration for Intrinsic Matrix</h1>
              <h4 class="mb-3"> <p>Using Zhangs method to compute the intrinsic matrix using Python NumPy</p> </h4>
            
          </div>
        </div>
      </div>
    </div>
    <!-- Jumbotron -->
    </div>        </div>
        
    <div class="container">
        <div class="justify-content-center">
        <article>
            <div class="justify-content-center">
                <h2 id="computing-the-intrinsic-camera-matrix-using-zhangs-algorithm">Computing the intrinsic camera matrix using Zhangs algorithm<a class="headerlink" href="#computing-the-intrinsic-camera-matrix-using-zhangs-algorithm" title="Permanent link">&para;</a></h2>
<p>Long time no blogging; but i am very interested in writing this article - the reason being i first used camera calibration in my second year, but that time I had OpenCV to use. ALthough, since that time I had decided to write a tutorial explaining the aspects of it as well. So first things first. I&rsquo;ll start this off mentioning about 2 articles that helped me get a clearer understanding of the method of calibration, then I will start off with what it is, how it is useful, which parameters it computes, etc. Also, to mention, this article delineates about the intrinsic matrix, and I will be covering {R|T} matrices along with distortion coefficients and image undistortion in an upcoming update to the blog article.</p>
<p>Firstly, some resources:</p>
<ol>
<li><a href="https://ieeexplore.ieee.org/document/888718/" target="_blank">Original Paper by Zhengyou Zhang &ndash; &ldquo;A flexible new technique for camera calibration&rdquo;</a> </li>
<li><a href="https://www.microsoft.com/en-us/research/publication/a-flexible-new-technique-for-camera-calibration/" target="_blank">Microsoft Technical Report for Camera Calibration</a></li>
<li><a href="http://staff.fh-hagenberg.at/burger/publications/reports/2016Calibration/Burger-CameraCalibration-20160516.pdf" target="_blank">Zhang’s Camera Calibration Algorithm: In-Depth Tutorial and Implementation - Report by Wilhelm Burger</a></li>
<li>I have also made my own notes, which is basically information from the above resources. <a href="{filename}/extra/Calibnotes.pdf" target="_blank">Uploaded it here</a></li>
<li>Implementation and source code for article : <a href="https://github.com/kushalvyas/CameraCalibration" target="_blank">https://github.com/kushalvyas/CameraCalibration</a></li>
</ol>
<p>I think one must read all of them to understand this subtle art of calibrating cameras. Although, I&rsquo;d like to recommend the <code>Microsoft technical report</code> as well as the <code>In-depth tutorial</code>.</p>
<p>Proceeding with the blog article. I shall cover the article in the following sequence.</p>
<ol>
<li>Image formation in a Camera <span class="math">\(\rightarrow\)</span> World and Image points</li>
<li>Concept of Camera Calibration</li>
<li>Intrinsic and Extrinsic Parameters</li>
<li>Types of distortions (Radial, Barrel, Pincushion)</li>
<li>Computation of the intrinsic camera calibration matrix</li>
<li>Computation of extrinsic parameters (To be Updated)</li>
<li>Distortion Coefficients and Undistortion (TO be Updated)</li>
</ol>
<p>Let&rsquo;s begin!</p>
<p>So here&rsquo;s how a pinhole camera works. Consider the image below. </p>
<p><center><img alt="im1" src="./images/calib/im1.png" /> <br><a href="https://www.mathworks.com/help/vision/ug/camera-calibration.html" target="_blank">Source: Mathworks</a></p>
<p>As seen, the visual pipeline is capturing the object in 3D from the World coordinate space and converting it through the the aperture ( pinhole, in this case) and projects onto the camera image plane. This leads to the formation of the image. <!-- Once this image has been extracted from the 3D world space, it is difficult (will need additional views) to reverse engineer the mere 2D representation of the image and try to reconstruct it back to the 3D world scene --> </p>
<p>The concept to be understood is that any point in the 3D world coordinate space is represented by <span class="math">\(P = (X, Y, Z)^T\)</span>. There is an essential conversion of the 3D world point <span class="math">\(P\)</span> to a local image coordinate space point, let&rsquo;s say <span class="math">\(p = (u, v)^T\)</span>. Hence for conversion of the points <span class="math">\(P \rightarrow p\)</span>, there is an effective projection transform ( just a matrix ) which enables so. The aim of calibration is to find the effective projection transform hence yielding significant information regarding the vision system such as focal lengths, camera pose, camera center, etc. I&rsquo;ll get to it too. Thus formulating a basic equation for the above paragraph, we can write it as:</p>
<div class="math">$$ [p] = M.[P] $$</div>
<p>where M is a projection matrix converting the World <span class="math">\((X, Y, Z, 1)\)</span> point to the Image <span class="math">\((u, v, 1)\)</span> point. This is a very casual representation of the above process happening through the visual pipeline.</p>
<p>On a broad view, the camera calibration yields us an intrinsic camera matrix, extrinsic parameters and the distortion coefficients. The basic model for a camera is a pinhole camera model, but today&rsquo;s cheap camera&rsquo;s incorporate high levels of noise/distortion in the images. For a simple visualization, I&rsquo;ll put 2 images below. Note that the image on the left shows an image captured by my logitech webcam, followed by the image on the right which shows an <code>undistorted</code> image. The straight lines appear to be bent (curved) in the left image, whereas in the right one it appears normal. </p>
<p><center>
<img alt="im2" height="136px" src="./images/calib/calib_radial.jpg" width="136px" />
<img alt="im3" height="136px" src="./images/calib/calib_result.jpg" width="136px" /></p>
<p><center>Source :<a href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_calib3d/py_calibration/py_calibration.html" target="_blank">OpenCV Camera Calibration docs</a></center>
</center></p>
<p>Hence, the camera calibration process is useful in providing an accurate input image to any computer vision system in the first place. (computer vision system which deal with pixel/real measurements. For other applications, it is not needed to compute this process). </p>
<p>So let&rsquo;s start with the camera calibration algorithm.</p>
<p><strong>Camera calibration</strong></p>
<p>We have established the the there basically is a transform that converts the world 3D point to an image point. However, there are a series of sub transforms in between that enable that. The 3D world coordinates undergo a Rigid Body Transform to get the same 3D World coordinates w.r.t the camera space. This newly obtained 3D set of coordinates are then projected into the camera&rsquo;s image plane yielding a 2D coordinate.</p>
<div class="math">$$ P (X, Y, Z) \overset{\mbox{\{Rigid Transform\}}}{\longrightarrow} P(X, Y, Z) \ w.r.t. camera's frame \overset{\mbox{\{Projective Transform\}}}{\longrightarrow} p(u, v)$$</div>
<p>The conversion due to the rigid transformation is due to the &ldquo;extrinsic parameters&rdquo;, which comprise of rotation and translation vectors, namely <span class="math">\(R\)</span> &amp; <span class="math">\(T\)</span>. On the other hand, the &ldquo;intrinsic parameters&rdquo; is the &ldquo;camera matrix&rdquo; which is a <span class="math">\(3\text{ x }3\)</span> matrix ( the projective transform).</p>
<p>This is how each of the matrices look like</p>
<p>__ Camera Matrix :(A) __</p>
<p>Where <span class="math">\(\alpha, \ \beta\)</span> is the focal length (<span class="math">\(f_x\)</span>, <span class="math">\(f_y\)</span>); <span class="math">\(\gamma\)</span> is pixel skew; (<span class="math">\(u_c,\  v_c\)</span>) is the camera center (origin) </center></p>
<div class="math">$$ \begin{bmatrix}
\alpha &amp; \gamma &amp; u_c\\
0 &amp; \beta &amp; v_c\\
0 &amp; 0 &amp; 1
\end{bmatrix} $$</div>
<p><strong>Algorithm for Camera Calibration</strong></p>
<p>The essence of camera calibration starts with estimating a matrix/transform which maps the World Coordinates to Image Plane coordinates. As described above, it eventually ends up being a equation in matrix form. However, let us start with preparing the initial data.</p>
<p>To estimate the transform, Zhang’s method requires images of a fixed geometric pattern; the images of which are taken from multiple views. Let&rsquo;s say the total number of views are <span class="math">\(M\)</span>. Given <span class="math">\(M\)</span> views, each view comprises of a set of points for which image and world coordinates are established. Consider <span class="math">\(N\)</span> points per view.</p>
<ol>
<li>For <span class="math">\(M\)</span> views, consider <span class="math">\(M\)</span> images from <span class="math">\(I_0\)</span> to <span class="math">\(I_{M-1}\)</span></li>
<li>
<p>For each image <span class="math">\(I_i\)</span> where i = (0 &hellip; M-1) : <span class="math">\(N\)</span> correspondence points are computed: <br>
For the above function one can use OpenCV&rsquo;s findchessboardcorners function. <a href="https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findchessboardcorners" target="_blank">cv2.findChessboardCorners</a> which returns a list of chessboard corners in the image. </p>
</li>
<li>
<p>Let the observed points be denoted as <span class="math">\(U\)</span> and the model points be represented as <span class="math">\(X\)</span>. For the image/observed points (U) extracted from the M views, let each point be denoted bu <span class="math">\(U_{i,j}\)</span>, where <span class="math">\(i\)</span> is the view ; and <span class="math">\(j\)</span> represents the extracted point (chessboard). Hence, <span class="math">\(U_{i,j} = ( u, v)\)</span>. At the same time, <span class="math">\(X\)</span> represents a similar structure as <span class="math">\(U\)</span>, with each point <span class="math">\(X_{i,j} = (X, Y, Z)\)</span></p>
</li>
<li>
<p>From each correspondence between model points and image points, compute an associated homography between the points. For each view, compute the homography.</p>
</li>
<li>
<p>From the set of estimated homographies, compute intrinsic parameters <span class="math">\(\alpha, \gamma, u_c, \beta , v_c\)</span>.</p>
</li>
<li>
<p>Update parameters using the LM-Optimizer.</p>
</li>
<li>
<p>Once the intrinsics are computed, Rotation and Translation Vectors (extrinsic) are estimated. </p>
</li>
<li>
<p>Using intrinsic and extrinsic parameters as initial guess for the LM Optimizer, refine all parameters.</p>
</li>
</ol>
<p>I&rsquo;ve described the complete algorithm for Zhang’s camera calibration. However this article will cover till point 6 -&gt; pertaining to the intrinsic params.</p>
<h2 id="implementation"><strong>Implementation</strong><a class="headerlink" href="#implementation" title="Permanent link">&para;</a></h2>
<p>We divide the implementation in the following parts</p>
<ol>
<li>Computing observed and model points correspondences.</li>
<li>Normalization</li>
<li>Compute view-wise homographies. </li>
<li>Refine Homography</li>
<li>Estimate Camera Intrinsic from homographies. </li>
</ol>
<p>pre {
  overflow: auto;
  word-wrap: normal;
  white-space: pre;
}</p>
<p><strong>Computing observed and model points</strong> </p>
<p>First of all steps is to collect sample images ( remember, there are M model views to be taken into account.) That means one has to capture <span class="math">\(M\)</span> images through the camera, such that each of the <span class="math">\(M\)</span> images are at a unique position in the camera&rsquo;s field of view. Once those image sets are captures, we proceed to marking correspondences between the model and the images.</p>
<p>Let&rsquo;s just mention the imports and other variables.</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code>    <span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">glob</span>
    <span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">argparse</span>
    <span class="kn">import</span> <span class="nn">pprint</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span> <span class="k">as</span> <span class="n">opt</span>


    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">puts</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span>

    <span class="n">DATA_DIR</span> <span class="o">=</span> <span class="s2">&quot;/&lt;path to data&gt;/data/&quot;</span>
    <span class="n">DEBUG_DIR</span> <span class="o">=</span> <span class="s2">&quot;/&lt;path to data&gt;/data/debug/&quot;</span>
    <span class="n">PATTERN_SIZE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">SQUARE_SIZE</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1">#</span>
</code></pre></div></td></tr></table></div>

<p>The post will use OpenCV&rsquo;s <code>cv2.findChessboardCorners</code> function for locating chessboard corners from the image. Other than that everything is computed using <code>NumPy</code>.</p>
<ol>
<li>Store the images in a <code>DATA</code> directory.</li>
<li>Make an additional directory <code>DATA/DEBUG/</code> to store debug images <br>.<br>.  <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code>    <span class="k">def</span> <span class="nf">show_image</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">()</span>

    <span class="c1"># read images from DATA_DIR, one at a time</span>
    <span class="c1"># returns image path, as well as image in grayscale</span>
    <span class="k">def</span> <span class="nf">get_camera_images</span><span class="p">():</span>
        <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">each</span> <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">DATA_DIR</span> <span class="o">+</span> <span class="s2">&quot;*.jpg&quot;</span><span class="p">)]</span>
        <span class="n">images</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">each</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">each</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>

</li>
</ol>
<p><br></p>
<ol>
<li>Computing the Chessboard corners using the <code>cv2.findChessboardCorners</code> function. One can note 
there is an array for <code>image_points</code> which holds the image coordinates for the chessboard corners. 
Also, the array named <code>object_points</code> holds the world coordinates for the same.</li>
</ol>
<p><strong>WHY CHESSBOARD!</strong> : Zhangs method, or even camera calibration in general is concerned with obtaining an transform from real world 3D to image 2D coordinates. Since the grid pattern formed on a chessboard is a really simple,  linear pattern, it is natural to go with it. That being said, geometric calibration also requires a mapping for the world and image coordinates. The reason i emphasize on this point is to understand the structure and &ldquo;shape&rdquo; (numpy users will be familiar to &ldquo;shape&rdquo;) of the previously defined <span class="math">\(U\)</span> and <span class="math">\(X\)</span> data points. </p>
<p>Now, <span class="math">\(U\)</span> is a array/list/matrix/data structure containing of all points in an image <span class="math">\(U_i\)</span>. So a given points inside an image will be <span class="math">\(U_{i,j} = (u, v)\)</span> given that <span class="math">\(i\)</span> is the <span class="math">\(i^{th}\)</span> model view ( <span class="math">\(i = (0, M-1)\)</span> , and <span class="math">\(j\)</span> is the <span class="math">\(j^{th}\)</span> point inside the <span class="math">\(i^{th}\)</span> image, where <span class="math">\(j = (0, N-1)\)</span>.</p>
<p>One can image it as a vector as follows</p>
<p><center>
</p>
<div class="math">$$
\begin{bmatrix}
    u_{0, 0} = (u_0, v_0) \\
    u_{0, 1} = (u_1, v_1) \\
    \vdots \\
    u_{0, N-1} = (u_{N-1}, v_{N-1})  
\end{bmatrix}
$$</div>
<p>and eventually, for all <span class="math">\(M\)</span> Views : </p>
<div class="math">$$
\begin{bmatrix}
    u_{0, 0} = (u_0, v_0) \\
    \vdots \\
    u_{0, N-1} = (u_{N-1}, v_{N-1})  
    \vdots \\
    \vdots \\
    \vdots \\
    \vdots \\
    u_{N-1, 0} = (u_0, v_0) \\
    \vdots \\
    u_{N-1, N-1} = (u_{N-1}, v_{N-1})   \\
\end{bmatrix}
$$</div>
<p></center></p>
<p>Hence, the above mention.</p>
<p>Secondly, as mentioned previously in the introduction, we are there has to be correspondences established before we compute the transfer matrix. Every point belonging to the image plane has coordinates <span class="math">\((u,v)\)</span>. The real world 3D point corresponding to it will be of the format <span class="math">\((X, Y, Z)\)</span>. So technically, there needs to be a transform that maps, </p>
<div class="math">$$
U(u, v, 1)^T = [M] . P(X, Y, Z, 1)^T
$$</div>
<p>Hence, we also create an array for the model/realworld points which establishes the correspondences. I have mentioned a parameter <code>SQUARE_SIZE</code> previously which is the size of the chessboard square (cm). the next step is to create <span class="math">\(P\)</span> array of shape <span class="math">\(M \times (N \times 3)\)</span>. For each of the <span class="math">\(M\)</span> views, the array is a <span class="math">\(N \times 3\)</span> array which has <span class="math">\(N\)</span> rows, each of the <span class="math">\(N\)</span> rows having <span class="math">\((X, Y, Z)\)</span></p>
<p>Since we are using a chessboard, and we know the chessboard square size, it is easy to virtually compute physical locations of the chessboard corners in real world . Assuming a Point <span class="math">\(A = (0 ,0)\)</span>, every point can be expressed as <span class="math">\((A\hat{i} + A\hat{j}) + ( k \times \text{SQUARE_SIZE} (\hat{i} + \hat{j}))\)</span>, where k ranges upto <code>PATTERN_SIZE</code></p>
<p><center>
<img alt="chessboard" src="./images/calib/left1.jpg" />
<img alt="chessboard1" src="./images/calib/draw0.png" />
</center>
Below is the code for detecting chessboard_corners, and establishing correspondences between image_points(U) and model points (X).</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span></pre></div></td><td class="code"><div><pre><span></span><code>        <span class="k">def</span> <span class="nf">getChessboardCorners</span><span class="p">(</span><span class="n">images</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">objp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">PATTERN_SIZE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">PATTERN_SIZE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">objp</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">PATTERN_SIZE</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">objp</span> <span class="o">*=</span> <span class="n">SQUARE_SIZE</span>

            <span class="n">chessboard_corners</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">image_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">object_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">correspondences</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ctr</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">each</span><span class="p">)</span> <span class="ow">in</span> <span class="n">get_camera_images</span><span class="p">():</span> <span class="c1">#images:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Processing Image : &quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
                <span class="n">ret</span><span class="p">,</span> <span class="n">corners</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findChessboardCorners</span><span class="p">(</span><span class="n">each</span><span class="p">,</span> <span class="n">patternSize</span><span class="o">=</span><span class="n">PATTERN_SIZE</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Chessboard Detected &quot;</span><span class="p">)</span>
                    <span class="n">corners</span> <span class="o">=</span> <span class="n">corners</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">corners</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">objp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span>
                        <span class="c1"># print(objp[:,:-1].shape)</span>
                        <span class="n">image_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
                        <span class="n">object_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objp</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#append only World_X, World_Y. Because World_Z is ZERO. Just a simple modification for get_normalization_matrix</span>
                        <span class="n">correspondences</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">corners</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="n">objp</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)])</span>
                    <span class="k">if</span> <span class="n">visualize</span><span class="p">:</span>
                        <span class="c1"># Draw and display the corners</span>
                        <span class="n">ec</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">each</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_GRAY2BGR</span><span class="p">)</span>
                        <span class="n">cv2</span><span class="o">.</span><span class="n">drawChessboardCorners</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">PATTERN_SIZE</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
                        <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">DEBUG_DIR</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ctr</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.png&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Error in detection points&quot;</span><span class="p">,</span> <span class="n">ctr</span><span class="p">)</span>

                <span class="n">ctr</span><span class="o">+=</span><span class="mi">1</span>

            <span class="k">return</span> <span class="n">correspondences</span>
</code></pre></div></td></tr></table></div>

<ol>
<li><code>corners</code>: image points returned by <code>cv2.findChessboardCorners</code></li>
<li><code>image_points</code> : array for containing all points extracted. (<span class="math">\(u, v)\)</span> format</li>
<li><code>object_points</code> : object points <span class="math">\((X, Y, | Z=0)\)</span></li>
</ol>
<p><strong>Important</strong> : One important point to be noted during Zhang&rsquo;s algorithm is that for any object points P(X, Y, Z), since it is a planar method, <span class="math">\(Z=0\)</span>. To visualize this, consider the following diagram. As seen, below is sample origin of the chessboard real world system. X-Y Axis belong inside the plane of the chessboard, and Z-axis is normal to the chessboard.</p>
<p><center>
<img alt="image" src="./images/calib/axis.jpeg" /></p>
<p>Note that the Z-Axis is normal to the board, hence for every real world point Z=0
</center></p>
<h3 id="representation-of-the-correspondence"><strong>Representation of the correspondence</strong>:<a class="headerlink" href="#representation-of-the-correspondence" title="Permanent link">&para;</a></h3>
<p>This section details the construction of the transformation matrices required through this process. Let the image point be denoted by <span class="math">\(p\)</span> or <span class="math">\(U\)</span> (I&rsquo;ll keep alternating between these notations throughout). Also the model/world points are : <span class="math">\(X\)</span> or <span class="math">\(P\)</span>. </p>
<p>The conversion of model points to image points is as </p>
<div class="math">$$ P (X, Y, Z) \overset{\mbox{\{Rigid Transform\}}}{\longrightarrow} P(X, Y, Z) \ w.r.t. camera's frame \overset{\mbox{\{Projective Transform\}}}{\longrightarrow} p(u, v)$$</div>
<p>eventually leading to </p>
<div class="math">$$ p(u, v) = M . P(X, Y, Z)$$</div>
<p>where Matrix <span class="math">\(M\)</span> represents the required transformation from world to image point. However, there are 2 aspects in the above conversion. One is the rigid transform  ( extrinsic parameters) and then that is passed on to the intrinsic camera transform.</p>
<p>Hence, we can split the M-matrix into sub matrices , thus breaking down the flow into multiple blocks. Also, note that now the computations will be carried in homogeneous coordinate spaces, so, <span class="math">\(p(u,v) \rightarrow p(u, v, 1)\)</span> and <span class="math">\(P(X, Y, Z) \rightarrow P(X, Y, Z, 1)\)</span>. </p>
<div class="math">$$p(u, v, 1) = M. P(X, Y, Z, 1)$$</div>
<div class="math">$$p = A.[R | t]. \text{ } P$$</div>
<p>where <span class="math">\(A\)</span> resembles the intrinsic camera matrix (projective transform) and <span class="math">\([R | t]\)</span> resembles the rotation and translation of the camera pose. (extrinsic)</p>
<p>Assessing the shapes of each matrix, we can deduce that: </p>
<p><center></p>
<ul>
<li><span class="math">\(p\)</span> is a <span class="math">\(3 \times 1\)</span> matrix,</li>
<li><span class="math">\(A\)</span> is a <span class="math">\(3 \times 3\)</span> matrix,</li>
<li><span class="math">\([ R | t]\)</span> is a <span class="math">\(3 \times 4\)</span> matrix,</li>
<li><span class="math">\(P\)</span> is a <span class="math">\(4 \times 1\)</span> matrix.</li>
</ul>
<p></center></p>
<p>Therefore, 
</p>
<div class="math">$$p_{3 \times 1} = A_{3 \times 3} . [ R | t ]_{3 \times 4} .  P_{4 \times 1}$$</div>
<div class="math">$$
\begin{bmatrix}
u \\
v \\ 
1
\end{bmatrix} = 
\begin{bmatrix}
a_{00} &amp; a_{01} &amp; a_{02} \\
a_{10} &amp; a_{11} &amp; a_{12} \\
a_{20} &amp; a_{21} &amp; a_{22} 
\end{bmatrix}
\begin{bmatrix}
R_{00} &amp; R_{01} &amp; R_{02} &amp; T_{03} \\
R_{10} &amp; R_{11} &amp; R_{12} &amp; T_{13} \\
R_{20} &amp; R_{21} &amp; R_{22} &amp; T_{23} 
\end{bmatrix}
\begin{bmatrix}
X \\
Y \\ 
Z = 0 \\
1
\end{bmatrix}
$$</div>
<p>Since <span class="math">\(Z=0\)</span>, we can eliminate the third column of <span class="math">\([R|t]\)</span>, because the multiplication of that entire column will coincide with Z=0, resulting in a zero contribution. Hence, we can eliminate <span class="math">\(Z\)</span> from <span class="math">\(P\)</span> and the third column from <span class="math">\([R|t]\)</span>. </p>
<p><center>
<img alt="im323" src="./images/calib/reduce1.png" />
</center></p>
<p>Hence, the system reduces to a complete <span class="math">\(3 \times 3\)</span>  system.</p>
<div class="math">$$p_{3 \times 1} = A_{3 \times 3} . [ R - R_{:,3} | t ]_{3 \times 3} .  [P_{P-Z}]_{3 \times 1}$$</div>
<div class="math">$$
\begin{bmatrix}
u \\
v \\ 
1
\end{bmatrix} = 
\begin{bmatrix}
a_{00} &amp; a_{01} &amp; a_{02} \\
a_{10} &amp; a_{11} &amp; a_{12} \\
a_{20} &amp; a_{21} &amp; a_{22} 
\end{bmatrix}
\begin{bmatrix}
R_{00} &amp; R_{01}  &amp; T_{03} \\
R_{10} &amp; R_{11}  &amp; T_{13} \\
R_{20} &amp; R_{21}  &amp; T_{23} 
\end{bmatrix}
\begin{bmatrix}
X \\
Y \\ 
1
\end{bmatrix}
$$</div>
<h3 id="normalization-estimate-view-homographies"><strong>Normalization &amp; Estimate View Homographies</strong>:<a class="headerlink" href="#normalization-estimate-view-homographies" title="Permanent link">&para;</a></h3>
<p>The next step in the algorithm is to estimate homographies for each of the <span class="math">\(M\)</span> views. However, there is an intermediate step to normalize the points (refer to normaliztion function in the source code ).
An essential part of the estimating view homographies is to obtain a solution using Direct Linear transformation (will conver it in a later section). This requires normalization of the input data points around its mean. This makes sure the there is a finite DLT solution for the equations obtained while estimating the homography. </p>
<p><strong>What is homography</strong> : So i used  the word homography in the above paragraph. A Homography can be said a transform/matrix which essentially converts points from one coordinate space to another, like how the world points <span class="math">\(P\)</span> are being converted to image points <span class="math">\(p\)</span> through the matrix <span class="math">\([M]\)</span>. Hence, for each view,  there is a homography associated to it which converets <span class="math">\(P\)</span> to <span class="math">\(p\)</span>.</p>
<p>Hence, <span class="math">\(p \leftarrow [M].X\)</span>. This can be considered as the base equation from which we will compute <span class="math">\([M]\)</span>. I&rsquo;ll actually write <span class="math">\(H\)</span> instead of <span class="math">\(M\)</span>, so that it doesnt conflict with the number of views (M views ). </p>
<div class="math">$$ p \leftarrow H. X$$</div>
<div class="math">$$
\begin{bmatrix}
u \\
v \\
1
\end{bmatrix} = 
\begin{bmatrix}
h_{00} &amp; h_{01} &amp; h_{02} \\
h_{10} &amp; h_{11} &amp; h_{12} \\
h_{20} &amp; h_{21} &amp; h_{22} 
\end{bmatrix}
\begin{bmatrix}
X \\
Y \\
1
\end{bmatrix}
$$</div>
<p>Hence, on obtaining the results, </p>
<div class="math">$$ u = \frac{h_{00}. X + h_{01}. Y + h_{02}}{h_{20}. X + h_{21}. Y + h_{22}}$$</div>
<div class="math">$$ v = \frac{h_{10}. X + h_{11}. Y + h_{12}}{h_{20}. X + h_{21}. Y + h_{22}}$$</div>
<p>Hence, </p>
<div class="math">$$u.({h_{20}. X + h_{21}. Y + h_{22}}) - (h_{00}. X + h_{01}. Y + h_{02}) = 0$$</div>
<div class="math">$$v.({h_{20}. X + h_{21}. Y + h_{22}}) - (h_{10}. X + h_{11}. Y + h_{12}) = 0$$</div>
<p>We can remodel the above equation a simpler wayy..</p>
<div class="math">$$
\begin{pmatrix}
-X &amp; -Y &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; u.X &amp; u.Y &amp; u \\
0 &amp; 0 &amp; 0 &amp; -X &amp; -Y &amp; -1 &amp; v.X &amp; v.Y &amp; v
\end{pmatrix}
\begin{pmatrix}
h_{00} \\
h_{01} \\
h_{02} \\
h_{10} \\
h_{11} \\
h_{12} \\
h_{20} \\
h_{21} \\
h_{22} 
\end{pmatrix} = 0
$$</div>
<div class="math">$$A.x = 0 \text{}$$</div>
<p>This is for only one point located in one image. For <span class="math">\(N\)</span> points per image, just vertically stack the above matrix, and solve <code>AX=0</code> for the above system of points. For each point out of the N points, there are 2 rows obtained in the above representation. Hence, for N points, it will be <span class="math">\(2 \times N\)</span> rows. </p>
<div class="math">$$
\begin{pmatrix}
-X_0 &amp; -Y_0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; u_0 . X_0 &amp; u_0 . Y_0 &amp; u_0 \\
0 &amp; 0 &amp; 0 &amp; -X_0 &amp; -Y_0 &amp; -1 &amp; v_0 . X_0 &amp; v_0 . Y_0 &amp; v_0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
-X_{N-1} &amp; -Y_{N-1} &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; u_{N-1} . X_{N-1} &amp; u_{N-1} . Y_{N-1} &amp; u_{N-1} \\
0 &amp; 0 &amp; 0 &amp; -X_{N-1} &amp; -Y_{N-1} &amp; -1 &amp; v_{N-1} . X_{N-1} &amp; v_{N-1} . Y_{N-1} &amp; v_{N-1} \\
\end{pmatrix}_{(2 \times N, 9)}. \vec{h} = 0
$$</div>
<p>The formulation of the above matrix can be written in this loop</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1"># repeat these steps for each view</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_points</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of points in current view : &quot;</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of Matrix M : &quot;</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># create row wise allotment for each 0-2i rows</span>
    <span class="c1"># that means 2 rows.. </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">normalized_object_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1">#model points</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">normalized_image_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1">#image points</span>

        <span class="n">row_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="o">-</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="n">Y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">Y</span><span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
        <span class="n">row_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="n">Y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">Y</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_1</span>
        <span class="n">M</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_2</span>

        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;p_model </span><span class="si">{0}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> p_obs </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)))</span>
</code></pre></div></td></tr></table></div>

<p><br></p>
<p><strong>Computing the homography</strong>: </p>
<p>The above system shows an <code>Ax=0</code> system. The solution can be of two ways. The obvious trivial solution is <code>x=0</code>, however we are not looking for that. The other solution is to find a non-trivial finite solution such that Ax ~ 0, if not zero. However, the explaination to this lies along the lines of using a Null Space of vector A, such that the <span class="math">\( ||Ax||^2 \rightarrow min\)</span> . The solution for such a system can be computed using SVD. (SVD provides orthonormal vectors). </p>
<p><center>
<img alt="imsvd" src="./images/calib/svd.png" /></p>
<p>source: <a href="https://en.wikipedia.org/wiki/Singular-value_decomposition">SVD - Wikipedia</a></p>
<p></center></p>
<p>Similarly in our system, <code>A</code> matrix is of shape <span class="math">\((2 \times N, 9)\)</span>. Thus the decomposition of <code>A</code> returns </p>
<ol>
<li>U : Shape - <span class="math">\((2 \times N, 2 \times N)\)</span></li>
<li>S : Shape - <span class="math">\((2 \times N, 9)\)</span></li>
<li>V_transpose : Shape - <span class="math">\(9 \times 9\)</span></li>
</ol>
<p>Thus, computing solution for <span class="math">\(h\)</span>, we obtain</p>
<div class="highlight"><pre><span></span><code>        <span class="n">Solution</span> <span class="n">to</span> <span class="n">Ax</span><span class="o">=</span><span class="mi">0</span> <span class="o">/</span> <span class="n">M</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v_t</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">v_t</span><span class="p">[</span><span class="n">argmin</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
</code></pre></div>

<p>Since v_t is a <span class="math">\(9 \times 9\)</span> matrix, it indicates to have 9 rows, each row having other 9 elements. The solution <code>x</code> is obtained by picking the eigen vector corresponding to the minimum  value in S. This is obtained by selecting the row number, such that its index is same as the index of min value in S. Eventually leads to a row vectors of 9 columns. Thus the final solution to x : in our case (where it is a <span class="math">\(3 \times 3\)</span> matrix) is to reshape it.</p>
<p>Below is the python snippet for computing numpy svd, and returns a normalized homography matrix. The homography matrix need to be de-normalized as well, since the initial points are in a raw/de-normalized form. Normalization is used to make DLT (direct linear transformation) give an optimal solution.</p>
<div class="highlight"><pre><span></span><code>    <span class="c1"># M.h  = 0 . solve system of linear equations using SVD</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing SVD of M&quot;</span><span class="p">)</span>
    <span class="c1"># print(&quot;U : Shape {0} : {1}&quot;.format(u.shape, u))</span>
    <span class="c1"># print(&quot;S : Shape {0} : {1}&quot;.format(s.shape, s))</span>
    <span class="c1"># print(&quot;V_t : Shape {0} : {1}&quot;.format(vh.shape, vh))</span>
    <span class="c1"># print(s, np.argmin(s))</span>

    <span class="n">h_norm</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
    <span class="n">h_norm</span> <span class="o">=</span> <span class="n">h_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">returns</span> <span class="n">mormalized</span> <span class="n">homography</span> <span class="n">matrix</span>
</code></pre></div>

<p><br></p>
<p><strong>Refining Homographies</strong>:</p>
<p>To refine the homography, obtained per view, a non liner optimizer: Levenberg Marquadt is used. This can be done using <code>scipy.optimize</code>.    Refer the source code on github to know more about the <code>minimizer function</code> and the <code>jacobian</code>.</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span></pre></div></td><td class="code"><div><pre><span></span><code>    <span class="n">N</span> <span class="o">=</span> <span class="n">normalized_object_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">object_points</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">image_points</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="c1">#H is homography for given view.</span>
    <span class="n">h_prime</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="o">=</span><span class="n">minimizer_func</span><span class="p">,</span> \
                <span class="n">x0</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac_function</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;lm&quot;</span> <span class="p">,</span> \
                <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">N</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">h_prime</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span>  <span class="n">h_prime</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">/</span><span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">H</span>
</code></pre></div></td></tr></table></div>

<p><strong>Computing intrinsic params</strong>:
For each view we compute a homography. Let us maintain an array of size (M), where M being the number of views (donot confuse M - the number of views with the matrix M in M.h =0) Hence, for each of the M views, (i.e. M chessboard images), there are M homographies obtained. </p>
<p>thus, </p>
<div class="highlight"><pre><span></span><code>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_view_homography</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div>

<p><strong>But what was homography in the first place ?</strong> : We said that that </p>
<div class="math">$$ p(u, v, 1) \leftarrow H.P(X, Y, Z, 1) $$</div>
<p>Hence, the homography per view computed comprises of the intrinsic projection transform as well as the extrinsic rigid body transform. Hence, we can say that:</p>
<div class="math">$$ H = A. [R  | t]$$</div>
<p>At the same time, one can say that</p>
<div class="math">$$ p(u, v) = A [R  | t ]. P(X, Y, Z)$$</div>
<p>
If I mention the above equation in a strict column form, I get, </p>
<div class="math">$$
\begin{bmatrix}
u \\
v \\
1
\end{bmatrix} =
\begin{bmatrix}
A_0 &amp; A_1  &amp; A_2
\end{bmatrix}
\begin{bmatrix}
R_0 &amp; R_1  &amp; t_2
\end{bmatrix}
\begin{bmatrix}
X \\
Y \\
1
\end{bmatrix}
$$</div>
<p>where, <span class="math">\(H = A [R_0 , R_1, T_2]\)</span>, therefore: using the same column representation:</p>
<div class="math">$$
\begin{bmatrix}
h_0 &amp; h_1 &amp; h_2 
\end{bmatrix} = 
\lambda \times A \times [R_0 , R_1, T_2]
$$</div>
<p>Given that <span class="math">\(R_0\)</span>, and <span class="math">\(R_1\)</span> are orthonomal, their dot products is 0.Therefore, 
<span class="math">\(h_0 = \lambda \times A \times R_0\)</span> and <span class="math">\(h_1 = \lambda \times A \times R_1\)</span>. Thus, 
<span class="math">\(R_0 = A^{-1}. h_0\)</span>, and similarly for <span class="math">\(R_1\)</span>. This yields us <span class="math">\(R_0\)</span> and <span class="math">\(R_1\)</span>, and their dot product gives <span class="math">\(R^{T}_{0} . R_{1} = 0\)</span>. </p>
<div class="math">$$ h^{T}_{0}. (A^{-1})^{T} . (A^{-1}) . h_{1} = 0$$</div>
<p>Let <span class="math">\(B = (A^{-1})^{T} . (A^{-1})\)</span> (according to zhang&rsquo;s paper)
we define a symmetric matrix, B as :</p>
<div class="math">$$B = \begin{pmatrix}
B_{0} &amp; B_{1} &amp; B_{3} \\
B_{1} &amp; B_{2} &amp; B_{4} \\
B_{3} &amp; B_{4} &amp; B_{5} \\
\end{pmatrix} \text{or} 
\begin{pmatrix}
B_{11} &amp; B_{12} &amp; B_{13} \\
B_{21} &amp; B_{22} &amp; B_{23} \\
B_{31} &amp; B_{32} &amp; B_{33} 
\end{pmatrix}
$$</div>
<p>The next step is to build a matrix <span class="math">\(v\)</span> (note , small v), such that</p>
<div class="math">$$v_{ij} = 
\begin{bmatrix}
h_{i0}.h_{j0} \\ h_{i0}.h_{j1} + h_{i1}.h_{j0} \\ h_{i1}.h_{j1} \\
h_{i2}.h_{j0} + h_{i0}.h_{j2} \\ h_{i2}.h_{j1} + h_{i1}.h{_j2} \\ h{_i2}.h_{j2}
\end{bmatrix}
$$</div>
<p>Therefore, using the dot product constraint for <span class="math">\(B\)</span> mentioned above, we can get, </p>
<div class="math">$$
\begin{bmatrix}
v^{T}_{12} \\
(v_{11} - v_{22})
\end{bmatrix} . b = V.b = 0
$$</div>
<p>where <span class="math">\(b\)</span> is a representation of <span class="math">\(B\)</span> as a six dimensional vector <span class="math">\([B_0, B_1, B_2, B_3, B_4, B_5]\)</span></p>
<p>Again, the system is of the form Ax = 0, and the solution is computed using the <code>SVD(V)</code> which yields us <span class="math">\(b\)</span>, and by extension <span class="math">\(B\)</span>.</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span></pre></div></td><td class="code"><div><pre><span></span><code>    <span class="k">def</span> <span class="nf">get_intrinsic_parameters</span><span class="p">(</span><span class="n">H_r</span><span class="p">):</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H_r</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">v_pq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                    <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">],</span>
                    <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">+</span> <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">],</span>
                    <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">],</span>
                    <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">+</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">],</span>
                    <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">+</span> <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">],</span>
                    <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
                <span class="p">])</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">H_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_pq</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">)</span>
            <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">v_pq</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">),</span> <span class="n">v_pq</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">))</span>

        <span class="c1"># solve V.b = 0</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;V.b = 0 Solution : &quot;</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>

<p><br>
<strong>Estimating intrinsic params: <span class="math">\(\alpha, \beta, \gamma, u_c, v_c\)</span></strong>:</p>
<p>Once, <span class="math">\(B\)</span> is computed, it is pretty straightforward to compute the intrinsic parameters.</p>
<div class="math">$$v_c = (b[1] . b[3] - b[0] . b[4])/(b[0] . b[2] - b[1]^2)$$</div>
<div class="math">$$l = b[5] - (b[3]^2 + vc . (b[1] . b[2] - b[0] . b[4]))/b[0]$$</div>
<div class="math">$$alpha = np.sqrt((l/b[0]))$$</div>
<div class="math">$$beta = np.sqrt(((l . b[0])/(b[0] . b[2] - b[1]^2)))$$</div>
<div class="math">$$gamma = -1 . ((b[1]) . (alpha^2)  . (beta/l))$$</div>
<div class="math">$$uc = (gamma . vc/beta) - (b[3] . (alpha^2)/l)$$</div>
<p>Hence, <strong>A</strong> is: </p>
<div class="math">$$ A = \begin{bmatrix}
\alpha &amp; \gamma &amp; u_c\\
0 &amp; \beta &amp; v_c\\
0 &amp; 0 &amp; 1
\end{bmatrix} $$</div>
<p>Furthermore, A can be upudated along with the complete set of intrinsic and extrinsic parameters using Levenberg Marquadt.</p>
<h3 id="results">Results<a class="headerlink" href="#results" title="Permanent link">&para;</a></h3>
<p>I implemented using Python 2.7, and NumPy 1.12. for the given dataset of images, the following values are returned.</p>
<p><center>
<img alt="pics_calib" src="./images/calib/calibpics.png" />
</center></p>
<p>Camera Matrix:</p>
<div class="math">$$\begin{bmatrix}
826.53065764 &amp;  -1.58262613 &amp;  271.85569445 \\
  0.         &amp; 826.80638173 &amp;  223.27202318 \\
  0.         &amp;   0.         &amp;    1.         
\end{bmatrix}
$$</div>
<p>Using on OpenCV&rsquo;s sample images:
<center>
<img alt="imagepics2calib" src="./images/calib/calibpics2.png" />
</center>
Opencv <code>cv2.calibrateCamera() function</code> Camera MAtrix: 
</p>
<div class="math">$$
\begin{bmatrix}
532.79536563 &amp;    0.        &amp;  342.4582516 \\
 0.          &amp; 532.91928339 &amp; 233.90060514 \\
 0.          &amp;   0.         &amp;   1.         
\end{bmatrix}
$$</div>
<p>Camera matrix (above code):
</p>
<div class="math">$$
\begin{bmatrix}
535.85981472 &amp;  -2.33641346 &amp; 351.72727058 \\
  0.         &amp; 537.44026588 &amp; 235.75125989 \\
  0.         &amp;   0.         &amp;   1.         
\end{bmatrix}
$$</div>
<p>Implementation can be found at my github. <a href="https://github.com/kushalvyas/CameraCalibration" target="_blank">https://github.com/kushalvyas/CameraCalibration</a>.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
            </div>
        </article>
        </div>
    </div>

        
    </div>

<footer class="bg-light text-center text-lg-start">

    <div class="text-center p-3" style="background-color: rgba(248,249,250);">
      Created this website using Python, Pelican, Markdown, Jinja, Bootstrap, JQuery, FontAwesome, MDBootstrap
    </div>

</footer>

<!-- <footer style="background-color: #f8f9fa; text-align: center; margin-top: auto; position: sticky; top: 100vh;">
  <div style="padding: 1rem; background-color: rgba(248,249,250);">
    Created this website using Python, Pelican, Markdown, Jinja, Bootstrap, JQuery, FontAwesome, MDBootstrap
  </div>
</footer> -->
</body>
</html>